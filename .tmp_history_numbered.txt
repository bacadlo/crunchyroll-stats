   1: use crate::{auth::CrunchyrollClient, models::HistoryEntry};
   2: use anyhow::Result;
   3: use crunchyroll_rs::categories::{Category, CategoryInformation};
   4: use futures_util::StreamExt;
   5: use std::collections::{HashMap, HashSet};
   6: 
   7: fn capitalize(word: &str) -> String {
   8:     let mut chars = word.chars();
   9:     match chars.next() {
  10:         Some(first) => format!("{}{}", first.to_uppercase(), chars.as_str()),
  11:         None => String::new(),
  12:     }
  13: }
  14: 
  15: fn prettify_category(raw: &str) -> String {
  16:     raw.split('-')
  17:         .filter(|part| !part.is_empty())
  18:         .map(capitalize)
  19:         .collect::<Vec<_>>()
  20:         .join(" ")
  21: }
  22: 
  23: fn normalize_genres(genres: Vec<String>) -> Vec<String> {
  24:     let mut seen = HashSet::new();
  25:     let mut normalized = Vec::new();
  26: 
  27:     for genre in genres {
  28:         let trimmed = genre.trim();
  29:         if trimmed.is_empty() {
  30:             continue;
  31:         }
  32: 
  33:         let key = trimmed.to_lowercase();
  34:         if seen.insert(key) {
  35:             normalized.push(trimmed.to_string());
  36:         }
  37:     }
  38: 
  39:     normalized
  40: }
  41: 
  42: #[derive(Default)]
  43: struct CategoryTaxonomy {
  44:     titles_by_id: HashMap<String, String>,
  45: }
  46: 
  47: fn category_title_or_fallback(raw_id: &str, localized_title: &str) -> String {
  48:     let title = localized_title.trim();
  49:     if title.is_empty() {
  50:         return prettify_category(raw_id);
  51:     }
  52: 
  53:     title.to_string()
  54: }
  55: 
  56: async fn load_category_taxonomy(client: &crunchyroll_rs::Crunchyroll) -> CategoryTaxonomy {
  57:     let mut taxonomy = CategoryTaxonomy::default();
  58: 
  59:     let categories = match client.categories().await {
  60:         Ok(categories) => categories,
  61:         Err(error) => {
  62:             log::warn!("Failed to load category taxonomy: {}", error);
  63:             return taxonomy;
  64:         }
  65:     };
  66: 
  67:     for category in categories {
  68:         let parent_id = category.category.to_string();
  69:         taxonomy.titles_by_id.insert(
  70:             parent_id.clone(),
  71:             category_title_or_fallback(&parent_id, &category.localization.title),
  72:         );
  73:     }
  74: 
  75:     taxonomy
  76: }
  77: 
  78: fn resolve_genres(
  79:     raw_categories: Vec<Category>,
  80:     localized_categories: Vec<CategoryInformation>,
  81:     taxonomy: &CategoryTaxonomy,
  82: ) -> Vec<String> {
  83:     let mut category_ids = Vec::new();
  84:     let mut seen_ids = HashSet::new();
  85:     let mut localized_titles = HashMap::new();
  86: 
  87:     for category in localized_categories {
  88:         let category_id = category.category.to_string();
  89:         localized_titles.insert(
  90:             category_id.clone(),
  91:             category_title_or_fallback(&category_id, &category.localization.title),
  92:         );
  93: 
  94:         if seen_ids.insert(category_id.clone()) {
  95:             category_ids.push(category_id);
  96:         }
  97:     }
  98: 
  99:     for category in raw_categories {
 100:         let category_id = category.to_string();
 101:         if seen_ids.insert(category_id.clone()) {
 102:             category_ids.push(category_id);
 103:         }
 104:     }
 105: 
 106:     normalize_genres(
 107:         category_ids
 108:             .into_iter()
 109:             .map(|category_id| {
 110:                 localized_titles
 111:                     .get(&category_id)
 112:                     .or_else(|| taxonomy.titles_by_id.get(&category_id))
 113:                     .cloned()
 114:                     .unwrap_or_else(|| prettify_category(&category_id))
 115:             })
 116:             .collect(),
 117:     )
 118: }
 119: 
 120: pub struct History<'a> {
 121:     client: &'a CrunchyrollClient,
 122: }
 123: 
 124: impl<'a> History<'a> {
 125:     pub fn new(client: &'a CrunchyrollClient) -> Self {
 126:         Self { client }
 127:     }
 128: 
 129:     pub async fn fetch_history(&self, limit: Option<usize>) -> Result<Vec<HistoryEntry>> {
 130:         let mut history = Vec::new();
 131:         let taxonomy = load_category_taxonomy(&self.client.client).await;
 132:         let mut series_genres_cache: HashMap<String, Vec<String>> = HashMap::new();
 133:         let mut movie_listing_genres_cache: HashMap<String, Vec<String>> = HashMap::new();
 134:         let mut pagination = self.client.client.watch_history();
 135: 
 136:         if let Some(limit) = limit {
 137:             pagination.page_size(limit as u32);
 138:         }
 139: 
 140:         let mut index = 0usize;
 141:         while let Some(entry) = pagination.next().await {
 142:             let entry = entry?;
 143:             let playhead_ms = (entry.playhead as u64) * 1000;
 144:             let watched_at = Some(entry.date_played.to_rfc3339());
 145: 
 146:             let panel = match entry.panel {
 147:                 Some(panel) => panel,
 148:                 None => {
 149:                     let entry_id = entry.id.clone();
 150:                     let parent_id = entry.parent_id.clone();
 151:                     let parent_type = entry.parent_type.clone();
 152: 
 153:                     let from_entry_id =
 154:                         self.client.client.media_collection_from_id(&entry_id).await;
 155:                     if let Ok(panel) = from_entry_id {
 156:                         panel
 157:                     } else {
 158:                         let from_parent_id = if parent_id != entry_id {
 159:                             Some(
 160:                                 self.client
 161:                                     .client
 162:                                     .media_collection_from_id(&parent_id)
 163:                                     .await,
 164:                             )
 165:                         } else {
 166:                             None
 167:                         };
 168: 
 169:                         match from_parent_id {
 170:                             Some(Ok(panel)) => panel,
 171:                             Some(Err(parent_error)) => {
 172:                                 let entry_error = from_entry_id
 173:                                     .err()
 174:                                     .map(|error| error.to_string())
 175:                                     .unwrap_or_else(|| "unknown error".to_string());
 176:                                 log::warn!(
 177:                                     "Watch history entry {} had no panel and could not be resolved (parent_type={}, parent_id={}). entry lookup error: {}. parent lookup error: {}",
 178:                                     entry_id,
 179:                                     parent_type,
 180:                                     parent_id,
 181:                                     entry_error,
 182:                                     parent_error
 183:                                 );
 184:                                 continue;
 185:                             }
 186:                             None => {
 187:                                 let entry_error = from_entry_id
 188:                                     .err()
 189:                                     .map(|error| error.to_string())
 190:                                     .unwrap_or_else(|| "unknown error".to_string());
 191:                                 log::warn!(
 192:                                     "Watch history entry {} had no panel and could not be resolved (parent_type={}, parent_id={}). entry lookup error: {}. parent lookup skipped because parent id matched entry id.",
 193:                                     entry_id,
 194:                                     parent_type,
 195:                                     parent_id,
 196:                                     entry_error
 197:                                 );
 198:                                 continue;
 199:                             }
 200:                         }
 201:                     }
 202:                 }
 203:             };
 204: 
 205:             let history_entry = match panel {
 206:                 crunchyroll_rs::MediaCollection::Episode(episode) => {
 207:                     let duration_ms = episode.duration.num_milliseconds() as u64;
 208:                     let series_id = episode.series_id.clone();
 209:                     let content_id = episode.id.clone();
 210: 
 211:                     let thumbnail = episode
 212:                         .images
 213:                         .iter()
 214:                         .max_by_key(|img| img.width)
 215:                         .map(|img| img.source.clone());
 216: 
 217:                     let genres = if let Some(cached) = series_genres_cache.get(&series_id) {
 218:                         cached.clone()
 219:                     } else {
 220:                         let mut raw_categories = episode.categories.clone().unwrap_or_default();
 221:                         if raw_categories.is_empty() {
 222:                             match episode.series().await {
 223:                                 Ok(series) => {
 224:                                     raw_categories = series.categories.unwrap_or_default();
 225:                                 }
 226:                                 Err(error) => {
 227:                                     log::warn!(
 228:                                         "Failed to fetch series metadata for {}: {}",
 229:                                         series_id,
 230:                                         error
 231:                                     );
 232:                                 }
 233:                             }
 234:                         }
 235: 
 236:                         let localized_categories = match episode.categories().await {
 237:                             Ok(categories) => categories,
 238:                             Err(error) => {
 239:                                 log::warn!(
 240:                                     "Failed to fetch discover categories for series {}: {}",
 241:                                     series_id,
 242:                                     error
 243:                                 );
 244:                                 Vec::new()
 245:                             }
 246:                         };
 247: 
 248:                         let resolved =
 249:                             resolve_genres(raw_categories, localized_categories, &taxonomy);
 250:                         series_genres_cache.insert(series_id.clone(), resolved.clone());
 251:                         resolved
 252:                     };
 253: 
 254:                     HistoryEntry {
 255:                         id: format!("item-{}", index),
 256:                         media_type: "episode".to_string(),
 257:                         content_id: Some(content_id),
 258:                         series_id: Some(series_id),
 259:                         movie_listing_id: None,
 260:                         title: episode.series_title,
 261:                         episode_title: Some(episode.title),
 262:                         watched_at,
 263:                         progress_ms: Some(playhead_ms),
 264:                         duration_ms: Some(duration_ms),
 265:                         thumbnail,
 266:                         genres,
 267:                     }
 268:                 }
 269:                 crunchyroll_rs::MediaCollection::Movie(movie) => {
 270:                     let duration_ms = movie.duration.num_milliseconds() as u64;
 271:                     let content_id = movie.id.clone();
 272:                     let movie_listing_id = movie.movie_listing_id.clone();
 273: 
 274:                     let thumbnail = movie
 275:                         .images
 276:                         .thumbnail
 277:                         .iter()
 278:                         .max_by_key(|img| img.width)
 279:                         .map(|img| img.source.clone());
 280: 
 281:                     let genres = if let Some(cached) =
 282:                         movie_listing_genres_cache.get(&movie_listing_id)
 283:                     {
 284:                         cached.clone()
 285:                     } else {
 286:                         let genres = match movie.movie_listing().await {
 287:                             Ok(listing) => {
 288:                                 let raw_categories = listing.categories.clone().unwrap_or_default();
 289:                                 let localized_categories = match listing.categories().await {
 290:                                     Ok(categories) => categories,
 291:                                     Err(error) => {
 292:                                         log::warn!(
 293:                                             "Failed to fetch discover categories for movie listing {}: {}",
 294:                                             movie_listing_id,
 295:                                             error
 296:                                         );
 297:                                         Vec::new()
 298:                                     }
 299:                                 };
 300: 
 301:                                 resolve_genres(raw_categories, localized_categories, &taxonomy)
 302:                             }
 303:                             Err(error) => {
 304:                                 log::warn!(
 305:                                     "Failed to fetch movie listing {}: {}",
 306:                                     movie_listing_id,
 307:                                     error
 308:                                 );
 309:                                 Vec::new()
 310:                             }
 311:                         };
 312: 
 313:                         movie_listing_genres_cache.insert(movie_listing_id.clone(), genres.clone());
 314:                         genres
 315:                     };
 316: 
 317:                     HistoryEntry {
 318:                         id: format!("item-{}", index),
 319:                         media_type: "movie".to_string(),
 320:                         content_id: Some(content_id),
 321:                         series_id: None,
 322:                         movie_listing_id: Some(movie_listing_id),
 323:                         title: movie.title,
 324:                         episode_title: None,
 325:                         watched_at,
 326:                         progress_ms: Some(playhead_ms),
 327:                         duration_ms: Some(duration_ms),
 328:                         thumbnail,
 329:                         genres,
 330:                     }
 331:                 }
 332:                 crunchyroll_rs::MediaCollection::Series(series) => {
 333:                     let series_id = series.id.clone();
 334:                     let title = series.title.clone();
 335:                     let thumbnail = series
 336:                         .images
 337:                         .poster_wide
 338:                         .iter()
 339:                         .chain(series.images.poster_tall.iter())
 340:                         .max_by_key(|img| img.width)
 341:                         .map(|img| img.source.clone());
 342: 
 343:                     let genres = if let Some(cached) = series_genres_cache.get(&series_id) {
 344:                         cached.clone()
 345:                     } else {
 346:                         let raw_categories = series.categories.clone().unwrap_or_default();
 347:                         let localized_categories = match series.categories().await {
 348:                             Ok(categories) => categories,
 349:                             Err(error) => {
 350:                                 log::warn!(
 351:                                     "Failed to fetch discover categories for series {}: {}",
 352:                                     series_id,
 353:                                     error
 354:                                 );
 355:                                 Vec::new()
 356:                             }
 357:                         };
 358: 
 359:                         let resolved =
 360:                             resolve_genres(raw_categories, localized_categories, &taxonomy);
 361:                         series_genres_cache.insert(series_id.clone(), resolved.clone());
 362:                         resolved
 363:                     };
 364: 
 365:                     HistoryEntry {
 366:                         id: format!("item-{}", index),
 367:                         media_type: "series".to_string(),
 368:                         content_id: Some(series_id.clone()),
 369:                         series_id: Some(series_id),
 370:                         movie_listing_id: None,
 371:                         title,
 372:                         episode_title: None,
 373:                         watched_at,
 374:                         progress_ms: Some(playhead_ms),
 375:                         duration_ms: None,
 376:                         thumbnail,
 377:                         genres,
 378:                     }
 379:                 }
 380:                 crunchyroll_rs::MediaCollection::Season(season) => {
 381:                     let season_id = season.id.clone();
 382:                     let series_id = season.series_id.clone();
 383: 
 384:                     let genres = if let Some(cached) = series_genres_cache.get(&series_id) {
 385:                         cached.clone()
 386:                     } else {
 387:                         let resolved = match season.series().await {
 388:                             Ok(series) => {
 389:                                 let raw_categories = series.categories.clone().unwrap_or_default();
 390:                                 let localized_categories = match series.categories().await {
 391:                                     Ok(categories) => categories,
 392:                                     Err(error) => {
 393:                                         log::warn!(
 394:                                             "Failed to fetch discover categories for series {}: {}",
 395:                                             series_id,
 396:                                             error
 397:                                         );
 398:                                         Vec::new()
 399:                                     }
 400:                                 };
 401: 
 402:                                 resolve_genres(raw_categories, localized_categories, &taxonomy)
 403:                             }
 404:                             Err(error) => {
 405:                                 log::warn!(
 406:                                     "Failed to fetch series metadata for season {}: {}",
 407:                                     season_id,
 408:                                     error
 409:                                 );
 410:                                 Vec::new()
 411:                             }
 412:                         };
 413: 
 414:                         series_genres_cache.insert(series_id.clone(), resolved.clone());
 415:                         resolved
 416:                     };
 417: 
 418:                     HistoryEntry {
 419:                         id: format!("item-{}", index),
 420:                         media_type: "season".to_string(),
 421:                         content_id: Some(season_id),
 422:                         series_id: Some(series_id),
 423:                         movie_listing_id: None,
 424:                         title: season.title,
 425:                         episode_title: None,
 426:                         watched_at,
 427:                         progress_ms: Some(playhead_ms),
 428:                         duration_ms: None,
 429:                         thumbnail: None,
 430:                         genres,
 431:                     }
 432:                 }
 433:                 crunchyroll_rs::MediaCollection::MovieListing(listing) => {
 434:                     let movie_listing_id = listing.id.clone();
 435:                     let title = listing.title.clone();
 436:                     let thumbnail = listing
 437:                         .images
 438:                         .poster_wide
 439:                         .iter()
 440:                         .chain(listing.images.poster_tall.iter())
 441:                         .max_by_key(|img| img.width)
 442:                         .map(|img| img.source.clone());
 443: 
 444:                     let genres =
 445:                         if let Some(cached) = movie_listing_genres_cache.get(&movie_listing_id) {
 446:                             cached.clone()
 447:                         } else {
 448:                             let raw_categories = listing.categories.clone().unwrap_or_default();
 449:                             let localized_categories = match listing.categories().await {
 450:                                 Ok(categories) => categories,
 451:                                 Err(error) => {
 452:                                     log::warn!(
 453:                                     "Failed to fetch discover categories for movie listing {}: {}",
 454:                                     movie_listing_id,
 455:                                     error
 456:                                 );
 457:                                     Vec::new()
 458:                                 }
 459:                             };
 460: 
 461:                             let resolved =
 462:                                 resolve_genres(raw_categories, localized_categories, &taxonomy);
 463:                             movie_listing_genres_cache
 464:                                 .insert(movie_listing_id.clone(), resolved.clone());
 465:                             resolved
 466:                         };
 467: 
 468:                     HistoryEntry {
 469:                         id: format!("item-{}", index),
 470:                         media_type: "movie".to_string(),
 471:                         content_id: Some(movie_listing_id.clone()),
 472:                         series_id: None,
 473:                         movie_listing_id: Some(movie_listing_id),
 474:                         title,
 475:                         episode_title: None,
 476:                         watched_at,
 477:                         progress_ms: Some(playhead_ms),
 478:                         duration_ms: None,
 479:                         thumbnail,
 480:                         genres,
 481:                     }
 482:                 }
 483:                 _ => continue,
 484:             };
 485: 
 486:             history.push(history_entry);
 487:             index += 1;
 488:         }
 489: 
 490:         Ok(history)
 491:     }
 492: }
